10/2:
冷静，先从表达式做起。

10/8:
游戏流程：
游戏开始：
	决定玩家先攻顺序（Host决定，然后发给Client）
	抽初始卡牌（Host抽牌，发给Client，任务卡会优先被抽到）
	替换或者保留初始手牌（Client做选择是发命令给Host，Host收到计算并转发结果）
	玩家确定之后获得初始手牌，后攻玩家额外获得一张幸运币
回合：
	回合开始，水晶上限+1以及充满水晶，从牌库里抽一张牌加入手牌（如果是Client，向Host发送抽牌，Host返回抽到的牌）
	打牌（Client给Host发命令，Host计算结果发回Client）
	点结束回合按钮结束回合（Client给Host发命令）
游戏胜利：
	Host在计算结果的时候计算到一方生命值为0，那么发游戏结束的结果给所有人。

UI表演：
	一个桌面，桌面可以更换为不同的环境。炉石是2D的动态场景，我们可能会考虑处理成3D场景或者也用2D的动态场景，但是现在一块白板就够了。
	卡片是3D的，并且在桌面上可以投下阴影。应该是Canvas+一个透明的Plane用来做阴影。卡片的UI部分我已经做好一个模板了。
	抽初始卡牌会有三张卡牌从卡组里飞出来（考虑到这个奇怪的轨迹，我觉得应该是用Animation调曲线做的，不过调曲线对做3D位移轨迹好像也不是很好使），平铺展示在玩家的屏幕上。
		鼠标移动在卡片上会显示高亮，点X卡片上会显示一个X表示这个卡将会被替换，再次点击又会恢复正常状态。
		卡片的下方有确定，点击之后就会将剩余的卡牌保留并替换被打X的卡片。
		确定之后，卡片会从画面的中心飞到下方手牌的位置。
	回合开始抽卡，会有一张卡片从卡组飞到手牌。
	手牌中可用的卡片会被标记为高亮。将鼠标移动到卡片上，卡片会放大并显示在屏幕的下方。
	法术卡片在使用之后会有动画效果。
	随从卡片在使用之后会变成只显示立绘和攻击力生命值的状态，特殊的效果会具有一些特殊的标记显示在周围，比如剧毒，亡语等等。
	随从在攻击的时候会撞击目标卡片。
	我打算把人物，技能，武器都算成是一种卡片。所以参考他们和随从的对应形式。
	以上所有表现请自己打开炉石并看一遍（

10/15:
整理一下关于Record和同步的思路。Record是为了保证在数据传输无序且不可靠的情况下进行游戏同步提出的概念。
Record本身是有序的，每个Record都带有自己的序号，序号由创建Record的RecordManager分配，从0开始递增。
一个Record表示一次游戏状态的改变，其中包括了数据和逻辑。在被添加到RecordManager之后，Record会应用对游戏的改变。
如果一个Record被添加到RecordManager之后发现序号不连续，不连续的Record会被暂时挂起，直到连续的Record被添加进来才会应用所有连续的Record。
对于网络来讲，这个过程应该是由于Client发布命令或者游戏自身产生了改变，Host产生了新的Record，除了添加到本地以外，Host还应该把Record发给Client。
Client在收到Record之后应该把Record添加到RecordManager，如果RecordManager由于丢包或者乱序收到了不连续的Record，应该告诉Client请求Host重发缺失区间的Record。
如果RecordManager添加了已有序号的Record，则自动无视它们。

10/18:
Record这个设定本身没有问题，但是Record需要把发给Client的部分拆出去。并且Record也不应该再承担逻辑了，至少目前看不到什么理由这么做。
按照这个逻辑来讲，首先删掉Record的序号，因为Record不会因为网络传输而发生乱序了。Record依然承担逻辑，这样可以顺便做了Replay系统。
顺便应该把卡组的初始化也做成Record，确保只要有Record就可以完整的从头到尾还原一场游戏。考虑一下要不要给Record加上Revert，这样可以实现倒放之类的功能。
Witness继承Record的序号逻辑。网络依然检测Record的添加，但是给玩家转发的是Witness，每个Record会针对每个玩家生成不同的Witness，因为有可见性的差别。
Client收到Witness添加到WitnessManager，继承Record的请求重发逻辑。

10/19:
一个问题，请求重发的时候Host怎么给Client重发不属于自己的Witness？只能Host自己保存所有Witness了。
另外一个问题是Witness的序号如何确定？Record现在已经没有序号了，还有一个问题是每个Record都对所有人有Witness吗？
序号是为了网络而存在的，所以还是交给网络部分来决定吧。至于自己的，那肯定是有序的所以自己决定就可以了。这样就算有人没有Witness也没关系了。
OK，现在来重新过一遍游戏顺序。首先，决定所有玩家的行动顺序。
然后，按照顺序初始化玩家的卡牌并抽卡。

10/20:
想一个问题，Witness看到的Card是怎样的？对于不同玩家来讲，Witness可以看到Id，但是不一定可以看到卡片的类型。

11/1:
好，冷静的思考一下，在Client看来游戏是怎样的。
嗯，只要先整合一下Host就好了。

12/31:
Event结构应该没有问题。现在缺一个按照回合和顺序保存Event的结构。
思考一个问题，Witness究竟是在Event树结束之后生成还是在Event发生的时候生成？
另外Visiblity也有问题。Visibility的friends假定了Event具有所属的玩家，但是这个是不一定的。所以Visibility应该针对玩家而定。
那么按照这个结论来想，如果Event要在结束了之后再生成的话，Event就必须保存自己的可见性。这个我觉得应该是没必要的，所以Witness应该是随时根据可见性生成的。
Witness要在事件结束之后才发出去。另外现在Record被删除之后，onWitness的事件还需要额外实现。
思考一下，Witness要在事件结束之后才能得到事件的结果。但是Visiblity是在事件开始的时候给出的——艹，那直接在事件结束才给事件可见性不就行了嘛（
但是这样会有一个问题，那就是parentWitness没有产生的话childWitness要存在哪里？
想一想折中的方案，先生成结构，然后再copyVars。

2/1:
目前没有处理的问题有两个：
1.CardDefine放在哪里的问题。
2.Witness从核心层迁出的问题。

2/27:
整理一下从行为到Event到Witness的产生的过程。旧的情况是行为独立于Event，Event只是收录环境参数。新的Event在规则层面上由于不同的行为对应不同的Witness，三者是绑定的所以没有理由把行为放在Event外面。
决定了，首先Event现在具有行为，这样大概会产生大量的Event子类吧。游戏逻辑会大量的转移到Event中，那么行为也就不必依赖于规则的实现而是可以放在事件里面，执行逻辑只要执行对应的事件就行。
那么首先要对Event的结构进行修改，添加行为的虚方法，然后是派生原子行为的Event子类，最后是在规则层面派生VisibleEvent的子类对应规则上的各种阶段行为，并产生对应结构的Witness（其实到了这一步，不是很需要在意结构了）
Event对象怎么获得事件执行所需的信息？果然还是只能让Event自己构造自己。

——不能把Core暴露给前端，因为客户端很有可能并没有Core，隔着这么远也没法直接把Core的东西发过去。所以就算是添加玩家，也是没法直接让前端得知游戏的状况的。

3/19:
VisibleEvent如何处理树状结构？
啊，不做树状结构。VisibleEvent就是能看到的最顶级了。——等一下，发觉这个样不对。
这样的话，组合效果怎么显示就是一个问题了，所以Witness毫无疑问是有子Witness结构的。
绕了一圈又回到原来的地方了，很难受。

4/29:
效果行为分析：
1.战吼